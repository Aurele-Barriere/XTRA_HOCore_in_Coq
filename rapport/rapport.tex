\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage[nottoc, notlof, notlot]{tocbibind}
\usepackage{fullpage}
%\fullpage
\title{HOCore en Coq : résumé}


\author{Aurèle Barrière, sur un article de Petar Maskimovic \& Alan Schmitt}
\def\pic{$\pi$-calcul }
\def\barbue{\simeq}
\def\+{\oplus}

\begin{document}
\nocite{*}
\maketitle
\tableofcontents %je garde ca pendant que je travaille. ca s'en ira après
\section{Introduction à HOCore}
HOCore est un calcul de processus, semblable au lambda-calcul, utilisé en particulier pour décrire des exécutions distribuées de processus.

-> sémantique comportementale? je ne sais pas comment tourner ça

\subsection{Syntaxe}
Un processus, en HOCore, suit la grammaire suivante :
$$ P ::= a(x).P \mid \bar{a}\langle P\rangle \mid P\|P \mid x \mid 0 $$

On va distinguer 3 catégories : des canaux sur lesquels émettre et recevoir des messages (dans la grammaire ci-dessus, $a$ est un canal), des variables (remplacées lors de la lecture d'un message, $x$ dans la grammaire) et des processus ($P$ dans la grammaire).

Pour deux processus $P$ et $Q$, le processus $P\|Q$ correspond à l'éxecution en parallèle de $P$ et $Q$.


\subsection{Sémantique et simplifications}
$0$ est un processus qui ne fait rien.

En HOCore, l'éxécution en parallèle est associative et commutative, et le processus $0$ en est l'élément neutre.

Lorsqu'un processus émet un autre processus ou une variable sur un canal $a$ et qu'en parallèle un autre processus lit sur le même canal $a$, alors on peut faire la réduction suivante :

$\bar{a}\langle P\rangle\|a(x).Q \rightarrow [P/x]Q$, qui signifie que les instances de $x$ dans $Q$ sont remplacées par $P$.

Parmi les variables, il faut donc distinguer celles qui sont dites \textit{libres} et celles dites \textit{liées}. 
Une variable est liée lorsqu'elle peut être changée par la lecture sur un canal. On peut rapprocher ces notions à celles de variables \textit{globales} et \textit{locales}.
Dans l'exemple précédent, $x$ était donc une variable liée puisqu'elle est remplacée à la lecture sur le canal $a$. 



\section{Exemples de processus en HOCore}
\subsection{Récursivité}

On peut se demander s'il est possible de répliquer un processus. Et en effet, HOCore permet de décrire des exécutions infinies.

En se donnant un processus $P$, on cherche donc un processus $!P$ tel que $!P\rightarrow\up{*}P\|!P$, où $\rightarrow\up{*}$ signifie que le processus $!P$ se réduit en un certain nombres d'opérations à $P\|!P$.

Si on prend $$!P = (r(X).(X\|\bar{r}\langle X\rangle))\ \|\ \bar{r}\langle P\|r(X).(X\|\bar{r}\langle X\rangle)\rangle$$
À droite, on émet un processus sur le canal $r$, et donc on va remplacer à gauche $X$ par tout ce processus. Après son émission, le processus de droite se transforme en $0$ puisqu'il a fini d'émettre.
On a donc $$!P\rightarrow P\|r(X).(X\|\bar{r}\langle X\rangle)\ \|\ \bar{r}\langle P\|r(X).(X\|\bar{r}\langle X\rangle)\rangle\| 0$$
Et on constate qu'on a $!P\rightarrow P\|!P\|0$, et donc $!P\rightarrow P\|!P$ comme on le souhaitait, comme $0$ est l'élément neutre pour la parallèlisation.

\subsection{Choix de processus}
On aimerait également disposer d'un processus qui choisisse entre deux processus $P$ et $Q$ selon si il est exécuté en parallèle d'un processus $\hat{a_1}$ ou $\hat{a_2}$.

On souhaite donc avoir le processus $(a_1.P\+ a_2.Q)$ et les processus $\hat{a_1}$ et $\hat{a_2}$ tels que
$$(a_1.P\+ a_2.Q)\|\hat{a_1}\rightarrow\up{*}P$$
$$(a_1.P\+ a_2.Q)\|\hat{a_2}\rightarrow\up{*}Q$$

En HOCore, cela peut se faire ainsi :
$$(a_1.P\+ a_2.Q) = \bar{a_1}\langle P\rangle\ \|\ \bar{a_2}\langle Q\rangle$$
$$\hat{a_1} = a_1(X).(a_2(Y).(X))$$
$$\hat{a_2} = a_1(X).(a_2(Y).(Y))$$

Ainsi, si on a en parallèle les processus $(a_1.P\+ a_2.Q)$ et  $\hat{a_1}$, le premier va émettre $P$ et $Q$ sur les canaux $a_1$ et $a_2$, qui seront lus par le second, qui lui même ne va exécuter aprs lecture que le processus émis sur $a_1$ : $P$. %j'espère que c'est clair

\subsection{Turing Completude}
On a en particulier que HOCore est un calcul Turing-Complet. %référence nécessaire. pas besoin d'expliquer ce qu'est la Turing-complétude
Cela est montré dans l'article ... en encodant les mchines de Minsky dans HOCore.


\section{Équivalence de processus}
En HOCore, l'équivalence de processus est décidable. Pour comprendre cela, il convient de définir ce que sont deux processus équivalents.

Deux processus $P$ et $Q$ sont dits équivalents si :
\begin{itemize}
\item S'il existe une réduction de $P$ à un processus $P'$, il existe $Q'$ tel qu'il y a une réduction de $Q$ à $Q'$. %définir réduction? peut etre pas besoin de complexifier encore
\item $P$ et $Q$ ont les mêmes \textit{observables} : ils émettent des messages sur les mêmes canaux.  
\item Pour tout contexte $C$ (un processus avec un trou), le contexte complété avec $P$, $C[P]$, est équivalent à $C[Q]$.
\end{itemize}
Une des particularités de HOCore (contrairement au \pic par exemple), est que les processus ne peuvent pas \textit{cacher} des variables. On peut donc choisir un contexte qui explore le processus et ses actions sur les canaux et les variables.
%je pense qu'il faut un exemple ici


\section{Formalisation en Coq}
Un des principaux travaux de l'équipe de recherche a été de formaliser HOCore en Coq (l'assistant de preuve).
La grammaire relativement simple d'HOCore se traduit simplement en Coq, cependant des problèmes subsistent : il faut pouvoir reconnaître les variables liées dont le rôle est identique. En effet, deux processus peuvent s'écrire différemment mais être équivalents.

Par exemple, $a(X).(P\|X)$ et $a(Y).(P\|Y)$ sont équivalents, mais ne s'écrivent pas rigoureusement de la même manière.

\subsection{Alpha-conversion et représentation canonique locale des noms}
Dans l'exemple précédent, on parle d'alpha-conversion si deux processus ont des variables liées dont le nom a été changé. Cependant, il faut bien distingeur variables et liées et variables libres. On ne peut pas parler d'alpha-conversion pour des variables libres : le contexte peut utiliser ces variables libres et on pourrait alors perdre l'équivalence.

-> exemple

Si on veut pouvoir décider, avec Coq par exemple, de l'équivalence de deux processus, cela peut être un problème.

Pour le contourner, on peut entièrement se dispenser des noms de variables : on va disposer d'une fonction qui pour chaque variable va calculer une hauteur de manière identique et indépendante du nom. Cette approche est celle de \textit{représentation canonique locale des noms} introduite dans l'article ... .

On n'a plus alors d'alpha-conversion possible : les variables ne sont plus que des indices, qui seront égaux dans le cas de processus équivalents.



\subsection{Système de transitions étiquetées} %je pense qu'il faut le mettre dans la partie Coq puisque c'est pour aider à analyser. mais on pourrait aussi le mettre plus haut.
Pour pouvoir analyser un processus, trouver les communications entre les différents processus en parallèles sans modifier complètement sa syntaxe, on introduit une nouvelle forme de sémantique : un système de transitions étiquetées ou LTS (\textit{labeled transition system}). 

En effet, notre réduction pour la communication se formalise ainsi :
$$\bar{a}\langle P\rangle\|a(x).Q \rightarrow [P/x]Q$$

Cependant, on sait qu'on a défini la parallèlisation comme étant transitive. On peut donc se retrouver dans le cas
$$\bar{a}\langle P\rangle\|R\|S\|T\|U\|a(x).Q$$
Comment alors repérer la communication entre processus sans changer toute la syntaxe pour se retrouver avec le processus récepteur juste après le processus émetteur?

Le principe du LTS est d'indiquer le comportement de chaque processus et les réductions possibles avec celui-ci.%a réécrire peut etre

%exemple



\subsection{Correction de preuves}
Un des avantages de formaliser avec Coq HOCore a été de repérer des fautes dans des démonstrations.

Par exemple, une des preuves raisonne inductivement sur des tailles de processus mais en utilisant une structure différente de HOCore.

Dans une autre preuve, on affirme implicitement que la décomposition première d'un processus en forme normale reste en forme normale alors qu'il y a des contre-exemples.

Certines erreurs peuvent amener à redéfinir une notion pour pouvoir rester cohérent avec le reste des travaux.

Ces erreurs sont faciles à commettre à la main lorsque la complexité de la preuve en cache les subtilités, et refaire ces preuves en Coq garantit leur validité. Il s'agit cependant d'une grande partie du travail à effectuer : si la formalisation de Coq a nécessité 4000 lignes de code, les preuves s'étendent sur 22000 lignes. 

\section{Conclusion}



\newpage
\part*{Ancienne version}
\section{Introduction à HOCore}
\subsection{Pi-calcul}
Le \pic est un langage formel utilisé pour décrire, en particulier, les éxécutions distribuées de processus. Sa syntaxe, très simple, décrit simplement l'éxécution en parallèle.

En \pic, on manipule des processus, qui peuvent s'éxécuter séquentiellement ou parallèlement et terminer ou non. Des canaux sont également disponibles pour la réception et l'émission de messages ou de variables.

Le \pic utilise donc la grammaire suivante :
\begin{align*}
P &= 0 & \text{fin du processus} \\
&| !P &\text{répéter le processus}\\
&| P||P &\text{lancer les deux processus en parallèle}\\
&| x(y).P &\text{lire un message sur le canal $x$ pour remplacer $y$, puis lancer $P$}\\
&| \bar{x}(y).P &\text{envoyer le message $y$ sur le canal $x$, puis lancer $P$}\\
&| (\nu x)P &\text{réserver le nom $x$ pour le processus $P$}\\
\end{align*}

Il s'agit d'un calcul Turing Complet.

\subsection{Pi-calcul d'ordre supérieur : HOPi}
Pour l'ordre supérieur, on se permet de communiquer par les canaux aussi bien des noms (variables) que des processus.

Dans la grammaire proposée plus haut, $x$ et $y$ peuvent donc désigner des processus.

\subsection{HOCore}
Il s'agit d'une restriction qui conserve le caractère Turing Complet du \pic d'ordre supérieur. Il s'agit d'une restriction minimale. On peut le voir aussi comme du $\lambda$-calcul autorisant les calculs parallèles.

Les travaux de l'équipe se basent sur un premier arcticle : \textit{On the Expressiveness and Decidability of Higher-Order Process Calculi}, dans lequel est définie la syntaxe de HOCore. On y montre, entre autres, la Turing complétude.

La grammaire utilisée est la suivante :

\begin{align*}
P &= 0 \\
&| x \\
&| P||P\\
&| a(x).P \text{ (à la lecture d'une variable $y$ sur $a$, toutes les instances de $x$ dans $P$ seront remplacées par des $y$)}\\
&| \bar{a}(P) \\
\end{align*}

On va distinguer 3 catégories : des canaux sur lesquels émettre et recevoir des messages, des variables (remplacées lors de la lecture d'un message) et des processus.

Parmi les variables, il faut distinguer celles qui sont dites \textit{libres} et celles dites \textit{liées}.
Une variable est liée lorsqu'elle peut être changée par la lecture sur un canal. 

En HOCore, on utilise un système de transitions labelées pour décrire l'éxécution des processus. On utilise soit une étiquette de la forme $\bar{a}(P)$ pour une émission, $a(P)$ pour une réception de processus, ou $\tau$ pour une transition interne : par exemple lorsqu'on a simultanément une émission et une réception sur un même canal.


\subsection{Exemples de processus en HOCore}
\paragraph{Exemple de substitution} $\bar{a}(P)||a(x).Q \rightarrow [P/x]Q$, qui signifie que les instances de $x$ dans $Q$ sont ramplacées par $P$.
\paragraph{Exemple de variables liées et libres} $a(x).(P||y)$. Ici, les occurences de $x$ dans $P$ sont liées alors que $y$ est libre. %exemple directement pris de l'article KAM
%l'exemple est peut etre a déplacer puisque je parle de ces variables plus loin dans le rapport




\subsection{Réductions}
Lorsqu'un processus attend un message sur un canal et qu'en parallèle, un autre processus émet un message sur ce même canal, on remplace toutes les instances de la variable.




\section{Équivalence décidable}
On peut montrer que le problème de décision de l'équivalence de 2 processus est décidable.

Cependant, le problème de terminaison reste indécidable.

On dit que deux processus sont équivalents si leur comportement est identique, quel que soit le contexte. On définit ainsi la \textit{congruence barbue} : il s'agit de la plus grande relation d'équivalence (entre processus), notée $\barbue$, telle que :
\begin{itemize}
\item elle est stable par réduction. $P\barbue Q$, $P\rightarrow^\tau P'$ et $Q\rightarrow^\tau Q'$ impliquent $P'\barbue Q'$.
\item stable par contexte. Si $C$ est un contexte (\textit{i.e.} un processus avec un trou) et $P\barbue Q$, on a $C[P]\barbue C[Q]$. 
\item Si $P\barbue Q$, $P$ et $Q$ ont les mêmes observables : si $P$ émet un processus sur un canal pour devenir un autre processus, il existe pour $Q$ une transition qui émet sur le même canal un processus.
\end{itemize}

Le fait qu'en HOCore on ne puisse pas réserver des variables à des processus rend la congruence barbue décidable : on peut explorer le comportement d'un processus avec des contextes bien choisis.

\section{Alpha-conversion}
Le nom donné aux variables n'importe pas dans la sémantique d'un processus, mais pose un problème pour l'équivalence de processus.

%\section{Indices de De Bruijn}
%Il existe un moyen de se débarrasser des noms de var

\section{Formalisation en Coq}
Un des principaux travaux de l'équipe de recherche a été de formaliser HOCore en Coq (l'assistant de preuve).

\subsection{Axiomatisation et noms de variables}
On peut facilement traduire la grammaire de HOCore en Coq. Cependant, des problèmes subsistent : il faut pouvoir reconnaître les variables liées dont le rôle est identique (alpha-conversion). Deux processus peuvent s'écrire différemment mais être équivalents s'ils utilisent des noms de variables différents. %mettre un exemple?

Une première solution est d'utiliser l'indice de De Bruijn. %expliquer ou pas la peine?

L'approche choisie est celle du \textit{nom local} %locally named
de Pollack et al. dans \textit{A canonical locally named representation of binding}.

Le but est de ne pas essayer de faire de l'alpha-conversion, mais plutôt d'identifier chaque variable par un poids.
%plus d'explications nécessaires


Ainsi, parmi les variables, il faut distinguer celles qui sont dites \textit{libres} et celles dites \textit{liées}.
Une variable est liée pour un processus $P$ lorsqu'elle peut être changée par la lecture sur un canal dans $P$.



\subsection{Expression des transitions}
HOCore utilise un systeme de transition labelées (LTS). Il utilise 3 types de transition : pour l'émission et la réception sur un canal, ou une transition interne.

Mais ce systme utilise donc le nom des variables liées : ce qui pose encore le problème de l'alpha-conversion.


\section{Bissimilarités}


\section{Correction de preuves}
Un des avantages de formaliser avec Coq HOCore a été de repérer des fautes dans des démonstrations.

Par exemple, une des preuves raisonne inductivement sur des tailles de processus mais en utilisant une structure différente de HOCore.

Dans une autre preuve, on affirme implicitement que la décomposition première d'un processus en forme normale reste en forme normale alors qu'il y a des contre-exemples.

Certines erreurs peuvent amener à redéfinir une notion pour pouvoir rester cohérent avec le reste des travaux.

Ces erreurs sont faciles à commettre à la main lorsque la complexité de la preuve en cache les subtilités, et refaire ces preuves en Coq garantit leur validité. Il s'agit cependant d'une grande partie du travail à effectuer : si la formalisation de Coq a nécessité 4000 lignes de code, les preuves s'étendent sur 22000 lignes. 


\bibliographystyle{plain}
\bibliography{rapport.bib}

\end{document}
